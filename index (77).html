<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Immunization Tracker</title>
  <style>
    /* Ghana Health Service Color Scheme - Preserved Exactly */
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      background-color: #f0f8ff; /* Light blue background */
    }

    h1, h2 {
      color: #006400; /* Dark green (Ghana Health Service color) */
    }

    form {
      margin-bottom: 20px;
      background-color: #ffffff; /* White */
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    label {
      display: block;
      margin-top: 10px;
      color: #006400; /* Dark green */
    }

    input, select, button {
      margin-top: 5px;
      padding: 8px;
      width: 100%;
      max-width: 300px;
      border: 1px solid #006400; /* Dark green */
      border-radius: 4px;
    }

    button {
      background-color: #006400; /* Dark green */
      color: #ffffff; /* White */
      border: none;
      cursor: pointer;
    }

    button:hover {
      background-color: #004d00; /* Darker green */
    }

    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 20px;
      background-color: #ffffff; /* White */
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    th, td {
      border: 1px solid #ddd;
      padding: 8px;
      text-align: left;
    }

    th {
      background-color: #006400; /* Dark green */
      color: #ffffff; /* White */
    }

    .highlight-red {
      background-color: #ffcccc; /* Light red for defaulters */
    }

    .highlight-pink {
      background-color: #ffccff; /* Light pink for upcoming visits */
    }

    .highlight-yellow {
      background-color: #ffffcc; /* Light yellow for due soon */
    }

    /* Modal Styles */
    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }

    .modal-content {
      background-color: white;
      padding: 20px;
      border-radius: 8px;
      width: 80%;
      max-width: 800px;
      max-height: 80%;
      overflow-y: auto;
    }

    .close {
      float: right;
      cursor: pointer;
      color: #006400; /* Dark green */
      font-size: 24px;
      font-weight: bold;
    }

    /* Footer */
    footer {
      margin-top: 20px;
      text-align: center;
      color: #006400; /* Dark green */
    }

    /* Responsive Design */
    @media (max-width: 600px) {
      input, select, button {
        width: 100%;
      }
      table {
        font-size: 12px;
      }
    }

    /* Booking Form Styles */
    .booking-form {
      margin-top: 20px;
      border-top: 1px solid #ddd;
      padding-top: 20px;
    }

    .vaccine-checkbox {
      margin-right: 10px;
    }

    .vaccine-item {
      margin-bottom: 10px;
      padding: 8px;
      border: 1px solid #eee;
      border-radius: 4px;
    }

    /* Stats Cards */
    .stats-container {
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
      margin-bottom: 20px;
    }

    .stat-card {
      background-color: white;
      border-radius: 8px;
      padding: 15px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      flex: 1;
      min-width: 200px;
    }

    .stat-card h3 {
      margin-top: 0;
      color: #006400;
    }

    .stat-value {
      font-size: 24px;
      font-weight: bold;
      color: #006400;
    }

    /* Tabs */
    .tab-container {
      margin-bottom: 20px;
    }

    .tab-buttons {
      display: flex;
      margin-bottom: 10px;
    }

    .tab-button {
      padding: 10px 15px;
      background-color: #e0e0e0;
      border: none;
      cursor: pointer;
      margin-right: 5px;
      border-radius: 4px 4px 0 0;
    }

    .tab-button.active {
      background-color: #006400;
      color: white;
    }

    .tab-content {
      display: none;
      padding: 15px;
      background-color: white;
      border-radius: 0 0 4px 4px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .tab-content.active {
      display: block;
    }

    /* Loading spinner */
    .spinner {
      border: 4px solid rgba(0, 0, 0, 0.1);
      border-radius: 50%;
      border-top: 4px solid #006400;
      width: 30px;
      height: 30px;
      animation: spin 1s linear infinite;
      margin: 20px auto;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* Login form */
    .login-container {
      max-width: 400px;
      margin: 50px auto;
      padding: 20px;
      background-color: white;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .login-container h2 {
      text-align: center;
    }

    .login-container button {
      margin-top: 15px;
    }

    .error-message {
      color: red;
      margin-top: 10px;
    }

    /* Connection status */
    .connection-status {
      position: fixed;
      top: 10px;
      right: 10px;
      padding: 5px 10px;
      border-radius: 4px;
      font-weight: bold;
      z-index: 1000;
    }

    .online {
      background-color: #006400;
      color: white;
    }

    .offline {
      background-color: #8B0000;
      color: white;
    }

    /* Offline login notice */
    .offline-notice {
      background-color: #ffffcc;
      padding: 10px;
      border-radius: 4px;
      margin-bottom: 15px;
      text-align: center;
      border: 1px solid #ffcc00;
    }
  </style>
</head>
<body>
  <!-- Connection Status Indicator -->
  <div id="connectionStatus" class="connection-status" style="display: none;">
    Online
  </div>

  <!-- Login Section (shown by default) -->
  <div id="loginSection" class="login-container">
    <h2>Immunization Tracker Login</h2>
    <div id="offlineLoginNotice" class="offline-notice" style="display: none;">
      You are currently offline. Logging in with cached credentials.
    </div>
    <form id="loginForm">
      <label for="email">Email:</label>
      <input type="email" id="email" required>
      
      <label for="password">Password:</label>
      <input type="password" id="password" required>
      
      <button type="submit">Login</button>
      <button type="button" onclick="showRegisterForm()">Register</button>
      <div id="loginError" class="error-message"></div>
    </form>
  </div>

  <!-- Register Section (hidden by default) -->
  <div id="registerSection" class="login-container" style="display: none;">
    <h2>Register New Account</h2>
    <form id="registerForm">
      <label for="regEmail">Email:</label>
      <input type="email" id="regEmail" required>
      
      <label for="regPassword">Password (min 6 characters):</label>
      <input type="password" id="regPassword" required minlength="6">
      
      <label for="regFacility">Facility Name:</label>
      <input type="text" id="regFacility" required>
      
      <button type="submit">Register</button>
      <button type="button" onclick="showLoginForm()">Back to Login</button>
      <div id="registerError" class="error-message"></div>
    </form>
  </div>

  <!-- Main App Content (hidden until authenticated) -->
  <div id="appContent" style="display: none;">
    <h1>Immunization Tracker</h1>

    <!-- Facility Name Section -->
    <section id="facility">
      <h2>Facility Name: <span id="currentFacilityName"></span></h2>
      <form id="facilityForm">
        <label for="facilityName">Change Facility Name:</label>
        <input type="text" id="facilityName" required>
        <button type="submit">Save Facility Name</button>
      </form>
    </section>

    <!-- Stats Section -->
    <section id="stats">
      <h2>Statistics</h2>
      <div class="stats-container">
        <div class="stat-card">
          <h3>Total Children</h3>
          <div class="stat-value" id="totalChildren">0</div>
        </div>
        <div class="stat-card">
          <h3>Defaulters</h3>
          <div class="stat-value" id="totalDefaulters">0</div>
        </div>
        <div class="stat-card">
          <h3>Due Soon</h3>
          <div class="stat-value" id="totalDueSoon">0</div>
        </div>
        <div class="stat-card">
          <h3>Upcoming</h3>
          <div class="stat-value" id="totalUpcoming">0</div>
        </div>
      </div>
    </section>

    <!-- Section 1.0: Registration Form -->
    <section id="registration">
      <h2>Register Child</h2>
      <form id="registrationForm">
        <label for="childName">Child's Name:</label>
        <input type="text" id="childName" required>

        <label for="dob">Date of Birth:</label>
        <input type="date" id="dob" required>

        <label for="sex">Sex:</label>
        <select id="sex" required>
          <option value="Male">Male</option>
          <option value="Female">Female</option>
        </select>

        <label for="address">Address/Community:</label>
        <input type="text" id="address" required>

        <label for="contact">Contact (Optional):</label>
        <input type="text" id="contact">

        <button type="submit">Register</button>
      </form>
    </section>

    <!-- Section 1.1: Child Health Register -->
    <section id="childHealthRegister">
      <h2>Child Health Register</h2>
      <input type="text" id="search" placeholder="Search by name or reg no." oninput="filterChildren()">
      <table id="childTable">
        <thead>
          <tr>
            <th>Reg No.</th>
            <th>Name</th>
            <th>DOB</th>
            <th>Sex</th>
            <th>Address</th>
            <th>Contact</th>
            <th>Actions</th>
          </tr>
        </thead>
        <tbody>
          <!-- Rows will be populated dynamically -->
        </tbody>
      </table>
      <button onclick="exportToCSV()">Export to CSV</button>
      <button onclick="printRecords()">Print Records</button>
      <button onclick="backupData()">Backup Data</button>
      <input type="file" id="restoreFile" accept=".json" style="display: none;">
      <button onclick="document.getElementById('restoreFile').click()">Restore Data</button>
      <button onclick="clearAllData()" style="background-color: #ff0000; color: white;">Clear All Data</button>
      <button onclick="openHelpModal()">Help/Instructions</button>
      <button onclick="logout()" style="background-color: #8B0000;">Logout</button>
    </section>

    <!-- Section 1.2: Dashboard -->
    <section id="dashboard">
      <h2>Dashboard</h2>
      <div class="tab-container">
        <div class="tab-buttons">
          <button class="tab-button active" onclick="openTab('allRecords')">All Records</button>
          <button class="tab-button" onclick="openTab('defaulters')">Defaulters</button>
          <button class="tab-button" onclick="openTab('dueSoon')">Due Soon (7 days)</button>
          <button class="tab-button" onclick="openTab('upcoming')">Upcoming (30 days)</button>
        </div>
        
        <div id="allRecords" class="tab-content active">
          <table id="allRecordsTable">
            <thead>
              <tr>
                <th>Reg No.</th>
                <th>Name</th>
                <th>Completed Vaccines</th>
                <th>Booked Vaccines</th>
                <th>Next Visit Date</th>
                <th>Status</th>
                <th>Actions</th>
              </tr>
            </thead>
            <tbody>
              <!-- Rows will be populated dynamically -->
            </tbody>
          </table>
        </div>
        
        <div id="defaulters" class="tab-content">
          <table id="defaultersTable">
            <thead>
              <tr>
                <th>Reg No.</th>
                <th>Name</th>
                <th>Missed Vaccine</th>
                <th>Missed Date</th>
                <th>Days Overdue</th>
                <th>Actions</th>
              </tr>
            </thead>
            <tbody>
              <!-- Rows will be populated dynamically -->
            </tbody>
          </table>
        </div>
        
        <div id="dueSoon" class="tab-content">
          <table id="dueSoonTable">
            <thead>
              <tr>
                <th>Reg No.</th>
                <th>Name</th>
                <th>Due Vaccine</th>
                <th>Due Date</th>
                <th>Days Remaining</th>
                <th>Actions</th>
              </tr>
            </thead>
            <tbody>
              <!-- Rows will be populated dynamically -->
            </tbody>
          </table>
        </div>
        
        <div id="upcoming" class="tab-content">
          <table id="upcomingTable">
            <thead>
              <tr>
                <th>Reg No.</th>
                <th>Name</th>
                <th>Scheduled Vaccine</th>
                <th>Scheduled Date</th>
                <th>Days Remaining</th>
                <th>Actions</th>
              </tr>
            </thead>
            <tbody>
              <!-- Rows will be populated dynamically -->
            </tbody>
          </table>
        </div>
      </div>
    </section>

    <!-- Modal for Immunization Schedule -->
    <div id="immunizationModal" class="modal">
      <div class="modal-content">
        <span class="close" onclick="closeModal()">&times;</span>
        <h2>Immunization Schedule</h2>
        <table id="immunizationTable">
          <thead>
            <tr>
              <th>Vaccine</th>
              <th>Date Given</th>
              <th>Batch Number</th>
              <th>Place Given</th>
              <th>Remarks</th>
              <th>Next Visit</th>
            </tr>
          </thead>
          <tbody>
            <!-- Rows will be populated dynamically -->
          </tbody>
        </table>
        <button onclick="promptToBookNextVisit()">Save</button>
      </div>
    </div>

    <!-- Modal for Booking Next Visit -->
    <div id="bookingModal" class="modal">
      <div class="modal-content">
        <span class="close" onclick="closeBookingModal()">&times;</span>
        <h2>Book Next Visit</h2>
        <div class="booking-form">
          <h3>Select Vaccines for Next Visit:</h3>
          <div id="vaccineSelection">
            <!-- Vaccine checkboxes will be populated dynamically -->
          </div>
          <label for="nextVisitDate">Next Visit Date:</label>
          <input type="date" id="nextVisitDate" required>
          <button onclick="saveBooking()">Confirm Booking</button>
        </div>
      </div>
    </div>

    <!-- Modal for Viewing Records -->
    <div id="viewRecordsModal" class="modal">
      <div class="modal-content">
        <span class="close" onclick="closeViewRecordsModal()">&times;</span>
        <h2>View Immunization Records</h2>
        <div>
          <label for="selectChildren">Select Child(ren):</label>
          <select id="selectChildren" multiple>
            <!-- Options will be populated dynamically -->
          </select>
          <button onclick="viewSelectedChildrenRecords()">View Records</button>
        </div>
        <table id="viewRecordsTable">
          <thead>
            <tr>
              <th>Reg No.</th>
              <th>Name</th>
              <th>Vaccine</th>
              <th>Date Given</th>
              <th>Batch Number</th>
              <th>Place Given</th>
              <th>Remarks</th>
              <th>Next Visit</th>
              <th>Status</th>
            </tr>
          </thead>
          <tbody>
            <!-- Rows will be populated dynamically -->
          </tbody>
        </table>
      </div>
    </div>

    <!-- Modal for Editing Child Details -->
    <div id="editChildModal" class="modal">
      <div class="modal-content">
        <span class="close" onclick="closeEditChildModal()">&times;</span>
        <h2>Edit Child Details</h2>
        <form id="editChildForm">
          <label for="editChildName">Child's Name:</label>
          <input type="text" id="editChildName" required>

          <label for="editDob">Date of Birth:</label>
          <input type="date" id="editDob" required>

          <label for="editSex">Sex:</label>
          <select id="editSex" required>
            <option value="Male">Male</option>
            <option value="Female">Female</option>
          </select>

          <label for="editAddress">Address/Community:</label>
          <input type="text" id="editAddress" required>

          <label for="editContact">Contact (Optional):</label>
          <input type="text" id="editContact">

          <button type="submit">Save Changes</button>
        </form>
      </div>
    </div>

    <!-- Modal for Help/Instructions -->
    <div id="helpModal" class="modal">
      <div class="modal-content">
        <span class="close" onclick="closeHelpModal()">&times;</span>
        <h2>Help/Instructions</h2>
        <p>1. Register a child using the registration form.</p>
        <p>2. Update immunization records by clicking "Update" next to a child's name.</p>
        <p>3. Use the dashboard tabs to view defaulters, due soon, or all records.</p>
        <p>4. Export data to CSV or print records for offline use.</p>
        <p>5. Backup and restore data using the respective buttons.</p>
        <p>6. Clear all data if needed (use with caution).</p>
        <p>7. When saving immunization records, you'll be prompted to book the next visit.</p>
        <p>8. Select vaccines for the next visit and set the date in the booking form.</p>
        <p>9. The app works both online and offline. Data will sync when connection is restored.</p>
        <p>10. You can login without internet connection using cached credentials.</p>
      </div>
    </div>

    <!-- Footer -->
    <footer>
      Developed By NASARE SURAJ
    </footer>
  </div>

  <!-- Loading Spinner -->
  <div id="loadingSpinner" class="spinner" style="display: none;"></div>

  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-database-compat.js"></script>

  <!-- Dexie for IndexedDB -->
  <script src="https://unpkg.com/dexie@latest/dist/dexie.js"></script>

  <script>
    // Firebase configuration
    const firebaseConfig = {
      apiKey: "AIzaSyAFCbcUnWQhyKUeDOrZ3qwLJofzKxpG9nQ",
      authDomain: "immunization-tracker-a.firebaseapp.com",
      projectId: "immunization-tracker-a",
      storageBucket: "immunization-tracker-a.firebasestorage.app",
      messagingSenderId: "298313942544",
      appId: "1:298313942544:web:c2a87ff07e1350dd8cec95"
    };

    // Initialize Firebase
    const app = firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const database = firebase.database();

    // Initialize IndexedDB
    const db = new Dexie('ImmunizationTrackerDB');
    db.version(2).stores({
      children: 'id, regNo, name, dob, sex, address, contact, vaccinations, isDefaulter, lastUpdated',
      userData: 'id, facilityName, lastUpdated',
      pendingWrites: '++id, childId, action, data, timestamp',
      userCredentials: 'email, password, facilityName, lastLogin'
    });

    // Global variables
    let children = [];
    let facilityName = '';
    let unsavedVaccinations = {};
    let selectedChildIndex = null;
    let editChildIndex = null;
    let currentUser = null;
    let isOnline = navigator.onLine;
    let pendingWrites = [];
    let isOfflineLogin = false;

    // Vaccination Schedule
    const vaccinationSchedule = [
      "BCG at Birth",
      "OPV0 at Birth",
      "Hepatitis B at Birth",
      "OPV1 at 6 weeks",
      "Penta1 at 6 weeks",
      "PCV1 at 6 weeks",
      "Rotavirus1 at 6 weeks",
      "OPV2 at 10 weeks",
      "Penta2 at 10 weeks",
      "PCV2 at 10 weeks",
      "Rotavirus2 at 10 weeks",
      "OPV3 at 14 weeks",
      "Penta3 at 14 weeks",
      "PCV3 at 14 weeks",
      "Rotavirus3 at 14 weeks",
      "IPV1 at 14 weeks",
      "Malaria1 at 6 months",
      "Malaria2 at 7 months",
      "IPV2 at 7 months",
      "Malaria3 at 9 months",
      "Measles Rubella1 at 9 months",
      "Malaria4 at 18 months",
      "Measles Rubella2 at 18 months",
      "Men A at 18 months",
      "Vitamin A at 6 months",
      "Vitamin A at 12 months",
      "Vitamin A at 18 months",
      "Vitamin A at 24 months",
      "Vitamin A at 30 months",
      "Vitamin A at 36 months",
      "Vitamin A at 42 months",
      "Vitamin A at 48 months",
      "Vitamin A at 54 months",
      "Vitamin A at 60 months"
    ];

    // Update connection status
    function updateConnectionStatus() {
      const statusElement = document.getElementById('connectionStatus');
      statusElement.style.display = 'block';
      
      if (isOnline) {
        statusElement.textContent = 'Online';
        statusElement.className = 'connection-status online';
      } else {
        statusElement.textContent = 'Offline';
        statusElement.className = 'connection-status offline';
      }
    }

    // Listen for online/offline events
    window.addEventListener('online', () => {
      isOnline = true;
      updateConnectionStatus();
      processPendingWrites();
      
      // If we were in offline login mode, try to re-authenticate with Firebase
      if (isOfflineLogin) {
        const email = document.getElementById('email').value;
        const password = document.getElementById('password').value;
        if (email && password) {
          auth.signInWithEmailAndPassword(email, password)
            .then(() => {
              isOfflineLogin = false;
              document.getElementById('offlineLoginNotice').style.display = 'none';
            })
            .catch(error => {
              console.error("Error re-authenticating:", error);
            });
        }
      }
    });

    window.addEventListener('offline', () => {
      isOnline = false;
      updateConnectionStatus();
    });

    // Initialize connection status
    updateConnectionStatus();

    // Process pending writes when coming back online
    async function processPendingWrites() {
      if (!isOnline || !currentUser) return;

      try {
        const pending = await db.pendingWrites.toArray();
        if (pending.length === 0) return;

        showLoading(true);
        
        for (const write of pending) {
          try {
            switch (write.action) {
              case 'addChild':
                await database.ref('children/' + currentUser.uid + '/' + write.data.id).set(write.data);
                break;
              case 'updateChild':
                await database.ref('children/' + currentUser.uid + '/' + write.data.id).update(write.data);
                break;
              case 'deleteChild':
                await database.ref('children/' + currentUser.uid + '/' + write.childId).remove();
                break;
              case 'updateFacility':
                await database.ref('users/' + currentUser.uid).update({ facilityName: write.data });
                break;
              case 'registerUser':
                // Try to register the user with Firebase
                try {
                  const userCredential = await auth.createUserWithEmailAndPassword(
                    write.data.email, 
                    write.data.password
                  );
                  await database.ref('users/' + userCredential.user.uid).set({
                    facilityName: write.data.facilityName
                  });
                } catch (error) {
                  // If user already exists, just update the facility name
                  if (error.code === 'auth/email-already-in-use') {
                    const signIn = await auth.signInWithEmailAndPassword(
                      write.data.email,
                      write.data.password
                    );
                    await database.ref('users/' + signIn.user.uid).update({
                      facilityName: write.data.facilityName
                    });
                  } else {
                    throw error;
                  }
                }
                break;
            }
            await db.pendingWrites.delete(write.id);
          } catch (error) {
            console.error('Error processing pending write:', error);
          }
        }

        // Reload data after processing pending writes
        await loadUserData();
        showLoading(false);
      } catch (error) {
        console.error('Error processing pending writes:', error);
        showLoading(false);
      }
    }

    // Check for cached credentials and attempt offline login
    async function checkCachedCredentials() {
      try {
        const credentials = await db.userCredentials.toArray();
        if (credentials.length > 0) {
          const latestCredential = credentials.reduce((prev, current) => 
            (prev.lastLogin > current.lastLogin) ? prev : current
          );
          
          document.getElementById('email').value = latestCredential.email;
          document.getElementById('password').value = latestCredential.password;
          
          // If offline, show notice about offline login
          if (!isOnline) {
            document.getElementById('offlineLoginNotice').style.display = 'block';
          }
        }
      } catch (error) {
        console.error("Error checking cached credentials:", error);
      }
    }

    // Auth State Listener
    auth.onAuthStateChanged(async user => {
      if (user) {
        currentUser = user;
        await loadUserData();
        document.getElementById('loginSection').style.display = 'none';
        document.getElementById('registerSection').style.display = 'none';
        document.getElementById('appContent').style.display = 'block';
        processPendingWrites();
      }
    });

    // Login Form - Modified for offline capability
    document.getElementById('loginForm').addEventListener('submit', async function(e) {
      e.preventDefault();
      showLoading(true);
      
      const email = document.getElementById('email').value;
      const password = document.getElementById('password').value;
      
      try {
        if (isOnline) {
          // Try online login first
          await auth.signInWithEmailAndPassword(email, password);
          
          // Cache credentials for offline use
          await db.userCredentials.put({
            email: email,
            password: password,
            lastLogin: Date.now()
          });
        } else {
          // Offline login - check cached credentials
          const credentials = await db.userCredentials
            .where('email').equals(email)
            .and(cred => cred.password === password)
            .toArray();
            
          if (credentials.length > 0) {
            // Simulate auth state for offline use
            currentUser = {
              uid: 'offline-user-' + email.replace(/[^a-z0-9]/gi, ''),
              email: email,
              isOffline: true
            };
            
            isOfflineLogin = true;
            document.getElementById('offlineLoginNotice').style.display = 'block';
            
            await loadUserData();
            document.getElementById('loginSection').style.display = 'none';
            document.getElementById('registerSection').style.display = 'none';
            document.getElementById('appContent').style.display = 'block';
          } else {
            throw new Error('Invalid credentials or no cached data available for offline login');
          }
        }
        
        showLoading(false);
      } catch (error) {
        showLoading(false);
        document.getElementById('loginError').textContent = error.message;
      }
    });

    // Register Form - Modified to work offline
    document.getElementById('registerForm').addEventListener('submit', async function(e) {
      e.preventDefault();
      showLoading(true);
      
      const email = document.getElementById('regEmail').value;
      const password = document.getElementById('regPassword').value;
      const facility = document.getElementById('regFacility').value;
      
      try {
        if (isOnline) {
          // Online registration
          const userCredential = await auth.createUserWithEmailAndPassword(email, password);
          
          // Save facility name to user's data
          await database.ref('users/' + userCredential.user.uid).set({
            facilityName: facility
          });
          
          // Cache credentials
          await db.userCredentials.put({
            email: email,
            password: password,
            facilityName: facility,
            lastLogin: Date.now()
          });
        } else {
          // Offline registration - store in pending writes
          await db.pendingWrites.add({
            action: 'registerUser',
            data: {
              email: email,
              password: password,
              facilityName: facility
            },
            timestamp: Date.now()
          });
          
          // Cache credentials locally
          await db.userCredentials.put({
            email: email,
            password: password,
            facilityName: facility,
            lastLogin: Date.now()
          });
          
          // Simulate auth state for offline use
          currentUser = {
            uid: 'offline-user-' + email.replace(/[^a-z0-9]/gi, ''),
            email: email,
            isOffline: true
          };
          
          isOfflineLogin = true;
          document.getElementById('offlineLoginNotice').style.display = 'block';
          
          // Set facility name
          facilityName = facility;
          document.getElementById('facilityName').value = facilityName;
          document.getElementById('currentFacilityName').textContent = facilityName;
          
          // Save to IndexedDB
          await db.userData.put({
            id: currentUser.uid,
            facilityName: facilityName,
            lastUpdated: Date.now()
          });
          
          document.getElementById('loginSection').style.display = 'none';
          document.getElementById('registerSection').style.display = 'none';
          document.getElementById('appContent').style.display = 'block';
        }
        
        showLoading(false);
      } catch (error) {
        showLoading(false);
        document.getElementById('registerError').textContent = error.message;
      }
    });

    // Show Register Form
    function showRegisterForm() {
      document.getElementById('loginSection').style.display = 'none';
      document.getElementById('registerSection').style.display = 'block';
      document.getElementById('loginError').textContent = '';
      document.getElementById('registerError').textContent = '';
    }

    // Show Login Form
    function showLoginForm() {
      document.getElementById('loginSection').style.display = 'block';
      document.getElementById('registerSection').style.display = 'none';
      document.getElementById('loginError').textContent = '';
      document.getElementById('registerError').textContent = '';
    }

    // Logout
    function logout() {
      if (isOfflineLogin) {
        // For offline login, just reset the UI
        currentUser = null;
        isOfflineLogin = false;
        document.getElementById('loginSection').style.display = 'block';
        document.getElementById('appContent').style.display = 'none';
        document.getElementById('offlineLoginNotice').style.display = 'none';
      } else {
        // For online login, use Firebase logout
        auth.signOut();
      }
    }

    // Load User Data
    async function loadUserData() {
      showLoading(true);
      
      try {
        // Try to load from Firebase first if online and not in offline login mode
        if (isOnline && !isOfflineLogin) {
          // Load facility name from Firebase
          const userSnapshot = await database.ref('users/' + currentUser.uid).once('value');
          const userData = userSnapshot.val();
          
          if (userData && userData.facilityName) {
            facilityName = userData.facilityName;
            document.getElementById('facilityName').value = facilityName;
            document.getElementById('currentFacilityName').textContent = facilityName;
            
            // Save to IndexedDB
            await db.userData.put({
              id: currentUser.uid,
              facilityName: facilityName,
              lastUpdated: Date.now()
            });
          }
          
          // Load children data from Firebase
          const childrenSnapshot = await database.ref('children/' + currentUser.uid).once('value');
          const childrenData = childrenSnapshot.val();
          
          if (childrenData) {
            children = Object.values(childrenData);
            // Ensure each child has an ID
            Object.keys(childrenData).forEach(key => {
              const childIndex = children.findIndex(c => c.id === key);
              if (childIndex !== -1) {
                children[childIndex].id = key;
              }
            });
            
            // Save to IndexedDB
            await db.children.clear();
            await db.children.bulkPut(children.map(child => ({
              ...child,
              lastUpdated: Date.now()
            })));
          } else {
            children = [];
            await db.children.clear();
          }
        } else {
          // Offline - load from IndexedDB
          const localUserData = await db.userData.get(currentUser.uid || 'offline-user');
          if (localUserData) {
            facilityName = localUserData.facilityName;
            document.getElementById('facilityName').value = facilityName;
            document.getElementById('currentFacilityName').textContent = facilityName;
          } else if (isOfflineLogin) {
            // For new offline users, use the facility name from registration
            const credentials = await db.userCredentials
              .where('email').equals(currentUser.email)
              .first();
            
            if (credentials && credentials.facilityName) {
              facilityName = credentials.facilityName;
              document.getElementById('facilityName').value = facilityName;
              document.getElementById('currentFacilityName').textContent = facilityName;
              
              await db.userData.put({
                id: currentUser.uid,
                facilityName: facilityName,
                lastUpdated: Date.now()
              });
            }
          }
          
          children = await db.children.toArray();
        }
        
        updateStats();
        updateChildTable();
        updateAllTables();
        showLoading(false);
      } catch (error) {
        console.error("Error loading data:", error);
        showLoading(false);
        alert("Error loading data: " + error.message);
      }
    }

    // Save Facility Name
    document.getElementById('facilityForm').addEventListener('submit', async function(e) {
      e.preventDefault();
      showLoading(true);
      
      facilityName = document.getElementById('facilityName').value;
      
      try {
        if (isOnline && !isOfflineLogin) {
          await database.ref('users/' + currentUser.uid).update({
            facilityName: facilityName
          });
        } else {
          // Add to pending writes
          await db.pendingWrites.add({
            action: 'updateFacility',
            data: facilityName,
            timestamp: Date.now()
          });
        }
        
        // Update local storage
        await db.userData.put({
          id: currentUser.uid,
          facilityName: facilityName,
          lastUpdated: Date.now()
        });
        
        document.getElementById('currentFacilityName').textContent = facilityName;
        showLoading(false);
        alert('Facility name saved successfully!');
      } catch (error) {
        showLoading(false);
        alert('Error saving facility name: ' + error.message);
      }
    });

    // Generate unique registration number
    function generateRegNo() {
      const year = new Date().getFullYear();
      let count = children.filter(child => child.regNo && child.regNo.startsWith(year)).length + 1;
      let regNo = `${String(count).padStart(3, '0')}/${year}`;

      // Ensure the registration number is unique
      while (children.some(child => child.regNo === regNo)) {
        count++;
        regNo = `${String(count).padStart(3, '0')}/${year}`;
      }

      return regNo;
    }

    // Register child
    document.getElementById('registrationForm').addEventListener('submit', async function(e) {
      e.preventDefault();
      showLoading(true);

      const childName = document.getElementById('childName').value.trim();
      const dob = document.getElementById('dob').value;
      const today = new Date();

      // Check if child already exists
      if (children.some(child => child.name.toLowerCase() === childName.toLowerCase())) {
        alert('Child already registered.');
        showLoading(false);
        return;
      }

      if (new Date(dob) > today) {
        alert('Date of Birth cannot be in the future.');
        showLoading(false);
        return;
      }

      const child = {
        regNo: generateRegNo(),
        name: childName,
        dob: dob,
        sex: document.getElementById('sex').value,
        address: document.getElementById('address').value,
        contact: document.getElementById('contact').value,
        vaccinations: [],
        isDefaulter: false
      };

      try {
        // Generate ID for the child
        const childId = Date.now().toString();
        child.id = childId;
        
        if (isOnline && !isOfflineLogin) {
          // Save to Firebase
          await database.ref('children/' + currentUser.uid + '/' + childId).set(child);
        } else {
          // Add to pending writes
          await db.pendingWrites.add({
            action: 'addChild',
            data: child,
            timestamp: Date.now()
          });
        }
        
        // Save to IndexedDB
        await db.children.put({
          ...child,
          lastUpdated: Date.now()
        });
        
        children.push(child);
        updateChildTable();
        updateStats();
        updateAllTables();
        this.reset();
        showLoading(false);
        alert('You have successfully registered a new child!');
      } catch (error) {
        showLoading(false);
        alert('Error registering child: ' + error.message);
      }
    });

    // Update Child Table
    function updateChildTable(filteredChildren = children) {
      const tbody = document.querySelector('#childTable tbody');
      tbody.innerHTML = '';

      filteredChildren.forEach((child, index) => {
        const row = document.createElement('tr');
        row.innerHTML = `
          <td>${child.regNo}</td>
          <td>${child.name}</td>
          <td>${formatDate(child.dob)}</td>
          <td>${child.sex}</td>
          <td>${child.address}</td>
          <td>${child.contact || 'N/A'}</td>
          <td>
            <button onclick="openImmunizationModal('${child.id}')">Update</button>
            <button onclick="openEditChildModal('${child.id}')">Edit</button>
            <button onclick="deleteChild('${child.id}')">Delete</button>
          </td>
        `;
        tbody.appendChild(row);
      });
    }

    // Open Immunization Modal
    async function openImmunizationModal(childId) {
      showLoading(true);
      
      // Find child by ID
      const childIndex = children.findIndex(c => c.id === childId);
      if (childIndex === -1) {
        showLoading(false);
        alert('Child not found');
        return;
      }
      
      selectedChildIndex = childIndex;
      const modal = document.getElementById('immunizationModal');
      modal.style.display = 'flex';

      const tbody = document.querySelector('#immunizationTable tbody');
      tbody.innerHTML = '';

      const child = children[childIndex];
      const childKey = `${child.regNo}-${child.name}`;
      unsavedVaccinations[childKey] = unsavedVaccinations[childKey] || {};

      vaccinationSchedule.forEach(vaccine => {
        const existingVaccine = child.vaccinations.find(v => v.vaccine === vaccine);
        const unsavedDate = unsavedVaccinations[childKey][vaccine];

        const row = document.createElement('tr');
        row.innerHTML = `
          <td>${vaccine}</td>
          <td><input type="date" class="dateGiven" value="${unsavedDate || existingVaccine?.dateGiven || ''}" onchange="trackUnsavedDate(this, '${childKey}', '${vaccine}')"></td>
          <td><input type="text" class="batchNumber" value="${existingVaccine?.batchNumber || ''}" required></td>
          <td><input type="text" class="placeGiven" value="${existingVaccine?.placeGiven || ''}" required></td>
          <td><input type="text" class="remarks" value="${existingVaccine?.remarks || ''}" required></td>
          <td>${formatDate(existingVaccine?.nextVisit) || 'N/A'}</td>
        `;
        tbody.appendChild(row);
      });
      
      showLoading(false);
    }

    // Track unsaved dates
    function trackUnsavedDate(input, childKey, vaccine) {
      if (!unsavedVaccinations[childKey]) {
        unsavedVaccinations[childKey] = {};
      }
      unsavedVaccinations[childKey][vaccine] = input.value;
    }

    // Prompt to book next visit
    function promptToBookNextVisit() {
      const confirmation = confirm('Do you want to book the next visit for this child?');
      if (confirmation) {
        openBookingModal();
      } else {
        saveImmunization(false); // Save without booking next visit
      }
    }

    // Open Booking Modal
    function openBookingModal() {
      const modal = document.getElementById('bookingModal');
      modal.style.display = 'flex';

      const child = children[selectedChildIndex];
      const childKey = `${child.regNo}-${child.name}`;
      const vaccineSelection = document.getElementById('vaccineSelection');
      vaccineSelection.innerHTML = '';

      // Get vaccines that haven't been given yet (including checking unsaved dates)
      const givenVaccines = child.vaccinations
        .filter(v => v.dateGiven)
        .map(v => v.vaccine);
      
      // Also exclude vaccines with unsaved dates
      const unsavedDates = unsavedVaccinations[childKey] || {};
      const vaccinesWithUnsavedDates = Object.keys(unsavedDates).filter(v => unsavedDates[v]);
      
      // Get booked vaccines
      const bookedVaccines = child.vaccinations
        .filter(v => v.nextVisit && !v.dateGiven)
        .map(v => v.vaccine);
      
      // Available vaccines are those not given, not booked, and not having unsaved dates
      const availableVaccines = vaccinationSchedule.filter(v => 
        !givenVaccines.includes(v) && 
        !bookedVaccines.includes(v) &&
        !vaccinesWithUnsavedDates.includes(v)
      );

      if (availableVaccines.length === 0) {
        vaccineSelection.innerHTML = '<p>No vaccines available for booking.</p>';
        document.getElementById('nextVisitDate').disabled = true;
      } else {
        availableVaccines.forEach(vaccine => {
          const vaccineItem = document.createElement('div');
          vaccineItem.className = 'vaccine-item';
          vaccineItem.innerHTML = `
            <input type="checkbox" class="vaccine-checkbox" id="vaccine-${vaccine}" value="${vaccine}">
            <label for="vaccine-${vaccine}">${vaccine}</label>
          `;
          vaccineSelection.appendChild(vaccineItem);
        });
        document.getElementById('nextVisitDate').disabled = false;
      }
    }

    // Close Booking Modal
    function closeBookingModal() {
      const modal = document.getElementById('bookingModal');
      modal.style.display = 'none';
    }

    // Save Booking
    function saveBooking() {
      const nextVisitDate = document.getElementById('nextVisitDate').value;
      if (!nextVisitDate) {
        alert('Please select a next visit date.');
        return;
      }

      const checkboxes = document.querySelectorAll('.vaccine-checkbox:checked');
      if (checkboxes.length === 0) {
        alert('Please select at least one vaccine for the next visit.');
        return;
      }

      // First save the immunization data without next visit dates
      saveImmunization(true, nextVisitDate, Array.from(checkboxes).map(cb => cb.value));
    }

    // Save Immunization Data
    async function saveImmunization(bookNextVisit = false, nextVisitDate = null, nextVisitVaccines = []) {
      showLoading(true);
      
      const child = children[selectedChildIndex];
      const childKey = `${child.regNo}-${child.name}`;
      const rows = document.querySelectorAll('#immunizationTable tbody tr');

      // Validate mandatory fields
      let isValid = true;
      rows.forEach(row => {
        const dateGiven = row.querySelector('.dateGiven').value;
        const batchNumber = row.querySelector('.batchNumber').value;
        const placeGiven = row.querySelector('.placeGiven').value;
        const remarks = row.querySelector('.remarks').value;

        if (dateGiven && (!batchNumber || !placeGiven || !remarks)) {
          isValid = false;
          alert('Batch Number, Place Given, and Remarks are mandatory when Date Given is selected.');
        }
      });

      if (!isValid) {
        showLoading(false);
        return;
      }

      // Clear existing vaccinations
      child.vaccinations = [];
      
      // Save all vaccination data
      rows.forEach(row => {
        const vaccine = row.cells[0].textContent;
        const dateGiven = row.querySelector('.dateGiven').value;
        const batchNumber = row.querySelector('.batchNumber').value;
        const placeGiven = row.querySelector('.placeGiven').value;
        const remarks = row.querySelector('.remarks').value;

        if (dateGiven || batchNumber || placeGiven || remarks) {
          child.vaccinations.push({
            vaccine,
            dateGiven,
            batchNumber,
            placeGiven,
            remarks,
            nextVisit: '' // We'll handle next visits separately
          });
        }
      });

      // If booking next visit, add next visit dates to selected vaccines
      if (bookNextVisit && nextVisitDate && nextVisitVaccines.length > 0) {
        nextVisitVaccines.forEach(vaccine => {
          const existingVaccineIndex = child.vaccinations.findIndex(v => v.vaccine === vaccine);
          if (existingVaccineIndex !== -1) {
            child.vaccinations[existingVaccineIndex].nextVisit = nextVisitDate;
          } else {
            child.vaccinations.push({
              vaccine,
              dateGiven: '',
              batchNumber: '',
              placeGiven: '',
              remarks: '',
              nextVisit: nextVisitDate
            });
          }
        });
      }

      // Clear unsaved dates for this child
      if (unsavedVaccinations[childKey]) {
        delete unsavedVaccinations[childKey];
      }

      // Update defaulter status based on next visit dates
      updateDefaulterStatus(child);
      
      try {
        if (isOnline && !isOfflineLogin) {
          // Save to Firebase
          await database.ref('children/' + currentUser.uid + '/' + child.id).set(child);
        } else {
          // Add to pending writes
          await db.pendingWrites.add({
            action: 'updateChild',
            childId: child.id,
            data: child,
            timestamp: Date.now()
          });
        }
        
        // Save to IndexedDB
        await db.children.put({
          ...child,
          lastUpdated: Date.now()
        });
        
        closeModal();
        closeBookingModal();
        updateChildTable();
        updateStats();
        updateAllTables();
        showLoading(false);
        alert('Immunization data saved successfully!');
      } catch (error) {
        showLoading(false);
        alert('Error saving immunization data: ' + error.message);
      }
    }

    // Update Defaulter Status
    function updateDefaulterStatus(child) {
      const today = new Date();
      child.isDefaulter = child.vaccinations.some(vaccination => {
        if (!vaccination.nextVisit) return false;
        const nextVisitDate = new Date(vaccination.nextVisit);
        return nextVisitDate < today;
      });
    }

    // Close Modal
    function closeModal() {
      const modal = document.getElementById('immunizationModal');
      modal.style.display = 'none';
    }

    // Close View Records Modal
    function closeViewRecordsModal() {
      const modal = document.getElementById('viewRecordsModal');
      modal.style.display = 'none';
    }

    // Close Edit Child Modal
    function closeEditChildModal() {
      const modal = document.getElementById('editChildModal');
      modal.style.display = 'none';
    }

    // Close Help Modal
    function closeHelpModal() {
      const modal = document.getElementById('helpModal');
      modal.style.display = 'none';
    }

    // Delete Child
    async function deleteChild(childId) {
      if (confirm('Are you sure you want to delete this child?')) {
        showLoading(true);
        
        try {
          if (isOnline && !isOfflineLogin) {
            await database.ref('children/' + currentUser.uid + '/' + childId).remove();
          } else {
            // Add to pending writes
            await db.pendingWrites.add({
              action: 'deleteChild',
              childId: childId,
              timestamp: Date.now()
            });
          }
          
          // Remove from IndexedDB
          await db.children.delete(childId);
          
          children = children.filter(child => child.id !== childId);
          updateChildTable();
          updateViewRecordsModal();
          updateStats();
          updateAllTables();
          showLoading(false);
        } catch (error) {
          showLoading(false);
          alert('Error deleting child: ' + error.message);
        }
      }
    }

    // Filter Children
    function filterChildren() {
      const searchTerm = document.getElementById('search').value.toLowerCase();
      const filteredChildren = children.filter(child =>
        child.name.toLowerCase().includes(searchTerm) || child.regNo.includes(searchTerm)
      );
      updateChildTable(filteredChildren);
    }

    // Export to CSV
    function exportToCSV() {
      const headers = ["Reg No.", "Name", "Vaccine", "Date Given", "Next Visit", "Status"];
      const data = [];

      // Add all vaccination records to CSV
      children.forEach(child => {
        child.vaccinations.forEach(vaccination => {
          const today = new Date();
          let status = 'Upcoming';
          
          if (vaccination.dateGiven) {
            status = 'Completed';
          } else if (vaccination.nextVisit) {
            const nextVisitDate = new Date(vaccination.nextVisit);
            if (nextVisitDate < today) {
              const daysOverdue = Math.floor((today - nextVisitDate) / (1000 * 60 * 60 * 24));
              status = `Overdue (${daysOverdue} days)`;
            } else {
              const daysUntil = Math.ceil((nextVisitDate - today) / (1000 * 60 * 60 * 24));
              status = `Due in ${daysUntil} days`;
            }
          }

          data.push([
            child.regNo,
            child.name,
            vaccination.vaccine,
            formatDate(vaccination.dateGiven) || 'N/A',
            formatDate(vaccination.nextVisit) || 'N/A',
            status
          ]);
        });
      });

      const csvContent = "data:text/csv;charset=utf-8," +
        [headers, ...data].map(row => row.join(",")).join("\n");
      const encodedUri = encodeURI(csvContent);
      const link = document.createElement("a");
      link.setAttribute("href", encodedUri);
      link.setAttribute("download", "immunization_records.csv");
      document.body.appendChild(link);
      link.click();
    }

    // Print Records
    function printRecords() {
      window.print();
    }

    // Backup Data
    function backupData() {
      const data = JSON.stringify(children, null, 2);
      const blob = new Blob([data], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = 'immunization_backup.json';
      link.click();
      URL.revokeObjectURL(url);
      alert('Backup downloaded successfully!');
    }

    // Restore Data
    document.getElementById('restoreFile').addEventListener('change', async function(e) {
      const file = e.target.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = async function(event) {
          try {
            const data = JSON.parse(event.target.result);
            if (confirm('Are you sure you want to restore this data? All current data will be replaced.')) {
              showLoading(true);
              
              // First clear existing data
              if (isOnline && !isOfflineLogin) {
                await database.ref('children/' + currentUser.uid).remove();
              }
              
              // Clear IndexedDB
              await db.children.clear();
              
              // Add the restored data
              const updates = {};
              for (const child of data) {
                if (isOnline && !isOfflineLogin) {
                  const newChildRef = database.ref('children/' + currentUser.uid).push();
                  child.id = newChildRef.key;
                  updates[child.id] = child;
                }
                
                // Save to IndexedDB
                await db.children.put({
                  ...child,
                  lastUpdated: Date.now()
                });
              }
              
              if (isOnline && !isOfflineLogin) {
                await database.ref('children/' + currentUser.uid).update(updates);
              }
              
              children = data;
              updateChildTable();
              updateStats();
              updateAllTables();
              showLoading(false);
              alert('Data restored successfully!');
            }
          } catch (error) {
            alert('Invalid backup file. Please upload a valid JSON file.');
          }
        };
        reader.readAsText(file);
      }
    });

    // Clear All Data
    async function clearAllData() {
      if (confirm('Are you sure you want to clear ALL data? This cannot be undone.')) {
        showLoading(true);
        
        try {
          if (isOnline && !isOfflineLogin) {
            await database.ref('children/' + currentUser.uid).remove();
          }
          
          // Clear IndexedDB
          await db.children.clear();
          await db.pendingWrites.clear();
          
          children = [];
          updateChildTable();
          updateStats();
          updateAllTables();
          showLoading(false);
          alert('All data has been cleared.');
        } catch (error) {
          showLoading(false);
          alert('Error clearing data: ' + error.message);
        }
      }
    }

    // Open Help Modal
    function openHelpModal() {
      document.getElementById('helpModal').style.display = 'flex';
    }

    // Open Edit Child Modal
    async function openEditChildModal(childId) {
      showLoading(true);
      
      // Find child by ID
      const childIndex = children.findIndex(c => c.id === childId);
      if (childIndex === -1) {
        showLoading(false);
        alert('Child not found');
        return;
      }
      
      editChildIndex = childIndex;
      const modal = document.getElementById('editChildModal');
      modal.style.display = 'flex';

      const child = children[childIndex];
      document.getElementById('editChildName').value = child.name;
      document.getElementById('editDob').value = child.dob;
      document.getElementById('editSex').value = child.sex;
      document.getElementById('editAddress').value = child.address;
      document.getElementById('editContact').value = child.contact || '';
      
      showLoading(false);
    }

    // Save Edited Child Details
    document.getElementById('editChildForm').addEventListener('submit', async function(e) {
      e.preventDefault();
      showLoading(true);
      
      const child = children[editChildIndex];
      child.name = document.getElementById('editChildName').value.trim();
      child.dob = document.getElementById('editDob').value;
      child.sex = document.getElementById('editSex').value;
      child.address = document.getElementById('editAddress').value.trim();
      child.contact = document.getElementById('editContact').value.trim();

      try {
        if (isOnline && !isOfflineLogin) {
          await database.ref('children/' + currentUser.uid + '/' + child.id).set(child);
        } else {
          // Add to pending writes
          await db.pendingWrites.add({
            action: 'updateChild',
            childId: child.id,
            data: child,
            timestamp: Date.now()
          });
        }
        
        // Save to IndexedDB
        await db.children.put({
          ...child,
          lastUpdated: Date.now()
        });
        
        updateChildTable();
        updateViewRecordsModal();
        closeEditChildModal();
        showLoading(false);
        alert('Child details updated successfully!');
      } catch (error) {
        showLoading(false);
        alert('Error updating child details: ' + error.message);
      }
    });

    // Update All Tables
    function updateAllTables() {
      updateAllRecordsTable();
      updateDefaultersTable();
      updateDueSoonTable();
      updateUpcomingTable();
    }

    // Update All Records Table - Now shows each child only once with summary info
    function updateAllRecordsTable() {
      const tbody = document.querySelector('#allRecordsTable tbody');
      tbody.innerHTML = '';

      children.forEach((child, index) => {
        const today = new Date();
        
        // Get completed vaccines
        const completedVaccines = child.vaccinations
          .filter(v => v.dateGiven)
          .map(v => v.vaccine.split(' at ')[0])
          .join(', ');
        
        // Get booked vaccines with next visit dates
        const bookedVaccines = child.vaccinations
          .filter(v => v.nextVisit && !v.dateGiven)
          .map(v => ({
            vaccine: v.vaccine.split(' at ')[0],
            nextVisit: v.nextVisit
          }));
        
        // Find the earliest next visit date
        const nextVisitDates = bookedVaccines.map(v => new Date(v.nextVisit));
        const earliestNextVisit = nextVisitDates.length > 0 ? 
          new Date(Math.min(...nextVisitDates)) : null;
        
        // Determine status
        let status = 'Up to date';
        let rowClass = '';
        
        if (bookedVaccines.length > 0) {
          if (earliestNextVisit < today) {
            const daysOverdue = Math.floor((today - earliestNextVisit) / (1000 * 60 * 60 * 24));
            status = `Overdue (${daysOverdue} days)`;
            rowClass = 'highlight-red';
          } else {
            const daysUntil = Math.ceil((earliestNextVisit - today) / (1000 * 60 * 60 * 24));
            if (daysUntil <= 7) {
              status = `Due in ${daysUntil} days`;
              rowClass = 'highlight-yellow';
            } else {
              status = `Due in ${daysUntil} days`;
            }
          }
        }

        const row = document.createElement('tr');
        if (rowClass) row.className = rowClass;
        row.innerHTML = `
          <td>${child.regNo}</td>
          <td>${child.name}</td>
          <td>${completedVaccines || 'None'}</td>
          <td>${bookedVaccines.map(v => `${v.vaccine}`).join(', ') || 'None'}</td>
          <td>${earliestNextVisit ? formatDate(earliestNextVisit) : 'N/A'}</td>
          <td>${status}</td>
          <td><button onclick="openImmunizationModal('${child.id}')">Update</button></td>
        `;
        tbody.appendChild(row);
      });
    }

    // Update Defaulters Table - Now counts each child only once
    function updateDefaultersTable() {
      const today = new Date();
      const defaultersList = [];
      const countedChildren = new Set(); // Track children we've already counted
      
      // Find all defaulters (children with missed Next Visit dates)
      children.forEach(child => {
        if (countedChildren.has(child.regNo)) return; // Skip if already counted
        
        const missedVaccines = child.vaccinations.filter(v => {
          if (v.nextVisit && !v.dateGiven) {
            const nextVisitDate = new Date(v.nextVisit);
            return nextVisitDate < today;
          }
          return false;
        });
        
        if (missedVaccines.length > 0) {
          countedChildren.add(child.regNo); // Mark this child as counted
          
          // Find the most overdue vaccine for this child
          const mostOverdue = missedVaccines.reduce((prev, current) => {
            const prevDate = new Date(prev.nextVisit);
            const currentDate = new Date(current.nextVisit);
            return prevDate < currentDate ? prev : current;
          });
          
          const nextVisitDate = new Date(mostOverdue.nextVisit);
          const daysOverdue = Math.floor((today - nextVisitDate) / (1000 * 60 * 60 * 24));
          
          defaultersList.push({
            child,
            vaccination: mostOverdue,
            daysOverdue
          });
        }
      });

      const tbody = document.querySelector('#defaultersTable tbody');
      tbody.innerHTML = defaultersList.map(defaulter => {
        return `
          <tr>
            <td>${defaulter.child.regNo}</td>
            <td>${defaulter.child.name}</td>
            <td>${defaulter.vaccination.vaccine.split(' at ')[0]}</td>
            <td class="highlight-red">${formatDate(defaulter.vaccination.nextVisit)}</td>
            <td class="highlight-red">${defaulter.daysOverdue}</td>
            <td><button onclick="openImmunizationModal('${defaulter.child.id}')">Update</button></td>
          </tr>
        `;
      }).join('');

      if (defaultersList.length === 0) {
        tbody.innerHTML = '<tr><td colspan="6" style="text-align: center;">No defaulters found</td></tr>';
      }
    }

    // Update Due Soon Table (7 days)
    function updateDueSoonTable() {
      const today = new Date();
      const dueSoonList = [];
      const countedChildren = new Set(); // Track children we've already counted
      
      // Find all vaccines due in the next 7 days
      children.forEach(child => {
        if (countedChildren.has(child.regNo)) return; // Skip if already counted
        
        const dueSoonVaccines = child.vaccinations.filter(v => {
          if (v.nextVisit && !v.dateGiven) {
            const nextVisitDate = new Date(v.nextVisit);
            const daysUntil = Math.ceil((nextVisitDate - today) / (1000 * 60 * 60 * 24));
            return daysUntil > 0 && daysUntil <= 7;
          }
          return false;
        });
        
        if (dueSoonVaccines.length > 0) {
          countedChildren.add(child.regNo); // Mark this child as counted
          
          // Find the vaccine with the closest due date
          const closestDue = dueSoonVaccines.reduce((prev, current) => {
            const prevDate = new Date(prev.nextVisit);
            const currentDate = new Date(current.nextVisit);
            return prevDate < currentDate ? prev : current;
          });
          
          const nextVisitDate = new Date(closestDue.nextVisit);
          const daysUntil = Math.ceil((nextVisitDate - today) / (1000 * 60 * 60 * 24));
          
          dueSoonList.push({
            child,
            vaccination: closestDue,
            daysUntil
          });
        }
      });

      const tbody = document.querySelector('#dueSoonTable tbody');
      tbody.innerHTML = dueSoonList.map(item => {
        return `
          <tr>
            <td>${item.child.regNo}</td>
            <td>${item.child.name}</td>
            <td>${item.vaccination.vaccine.split(' at ')[0]}</td>
            <td class="highlight-yellow">${formatDate(item.vaccination.nextVisit)}</td>
            <td class="highlight-yellow">${item.daysUntil}</td>
            <td><button onclick="openImmunizationModal('${item.child.id}')">Update</button></td>
          </tr>
        `;
      }).join('');

      if (dueSoonList.length === 0) {
        tbody.innerHTML = '<tr><td colspan="6" style="text-align: center;">No vaccines due in the next 7 days</td></tr>';
      }
    }

    // Update Upcoming Table (30 days)
    function updateUpcomingTable() {
      const today = new Date();
      const upcomingList = [];
      const countedChildren = new Set(); // Track children we've already counted
      
      // Find all vaccines due in the next 30 days (but more than 7 days)
      children.forEach(child => {
        if (countedChildren.has(child.regNo)) return; // Skip if already counted
        
        const upcomingVaccines = child.vaccinations.filter(v => {
          if (v.nextVisit && !v.dateGiven) {
            const nextVisitDate = new Date(v.nextVisit);
            const daysUntil = Math.ceil((nextVisitDate - today) / (1000 * 60 * 60 * 24));
            return daysUntil > 7 && daysUntil <= 30;
          }
          return false;
        });
        
        if (upcomingVaccines.length > 0) {
          countedChildren.add(child.regNo); // Mark this child as counted
          
          // Find the vaccine with the closest due date
          const closestDue = upcomingVaccines.reduce((prev, current) => {
            const prevDate = new Date(prev.nextVisit);
            const currentDate = new Date(current.nextVisit);
            return prevDate < currentDate ? prev : current;
          });
          
          const nextVisitDate = new Date(closestDue.nextVisit);
          const daysUntil = Math.ceil((nextVisitDate - today) / (1000 * 60 * 60 * 24));
          
          upcomingList.push({
            child,
            vaccination: closestDue,
            daysUntil
          });
        }
      });

      const tbody = document.querySelector('#upcomingTable tbody');
      tbody.innerHTML = upcomingList.map(item => {
        return `
          <tr>
            <td>${item.child.regNo}</td>
            <td>${item.child.name}</td>
            <td>${item.vaccination.vaccine.split(' at ')[0]}</td>
            <td>${formatDate(item.vaccination.nextVisit)}</td>
            <td>${item.daysUntil}</td>
            <td><button onclick="openImmunizationModal('${item.child.id}')">Update</button></td>
          </tr>
        `;
      }).join('');

      if (upcomingList.length === 0) {
        tbody.innerHTML = '<tr><td colspan="6" style="text-align: center;">No vaccines due in the next 30 days</td></tr>';
      }
    }

    // Update Stats - Now counts each child only once
    function updateStats() {
      const today = new Date();
      let defaulterCount = 0;
      let dueSoonCount = 0;
      let upcomingCount = 0;
      const countedDefaulters = new Set();
      const countedDueSoon = new Set();
      const countedUpcoming = new Set();
      
      children.forEach(child => {
        let isDefaulter = false;
        let isDueSoon = false;
        let isUpcoming = false;
        
        child.vaccinations.forEach(vaccination => {
          if (vaccination.nextVisit && !vaccination.dateGiven) {
            const nextVisitDate = new Date(vaccination.nextVisit);
            if (nextVisitDate < today) {
              isDefaulter = true;
            } else {
              const daysUntil = Math.ceil((nextVisitDate - today) / (1000 * 60 * 60 * 24));
              if (daysUntil <= 7) {
                isDueSoon = true;
              } else if (daysUntil <= 30) {
                isUpcoming = true;
              }
            }
          }
        });
        
        if (isDefaulter) defaulterCount++;
        if (isDueSoon) dueSoonCount++;
        if (isUpcoming) upcomingCount++;
      });
      
      document.getElementById('totalChildren').textContent = children.length;
      document.getElementById('totalDefaulters').textContent = defaulterCount;
      document.getElementById('totalDueSoon').textContent = dueSoonCount;
      document.getElementById('totalUpcoming').textContent = upcomingCount;
    }

    // Tab Navigation
    function openTab(tabId) {
      // Hide all tab contents
      document.querySelectorAll('.tab-content').forEach(tab => {
        tab.classList.remove('active');
      });
      
      // Deactivate all tab buttons
      document.querySelectorAll('.tab-button').forEach(button => {
        button.classList.remove('active');
      });
      
      // Activate the selected tab
      document.getElementById(tabId).classList.add('active');
      
      // Activate the button for the selected tab
      event.currentTarget.classList.add('active');
    }

    // Format date to DD/MM/YYYY
    function formatDate(dateString) {
      if (!dateString) return '';
      const date = new Date(dateString);
      const day = String(date.getDate()).padStart(2, '0');
      const month = String(date.getMonth() + 1).padStart(2, '0');
      const year = date.getFullYear();
      return `${day}/${month}/${year}`;
    }

    // Show loading spinner
    function showLoading(show) {
      document.getElementById('loadingSpinner').style.display = show ? 'block' : 'none';
    }

    // Initialize
    document.addEventListener('DOMContentLoaded', () => {
      checkCachedCredentials();
    });
  </script>
</body>
</html>